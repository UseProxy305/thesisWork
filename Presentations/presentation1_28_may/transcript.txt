Hi guys, it is Berkay Ipek. Today, I am going to make a small presentation about my work. I was not able to attend last week's meeting since I was sick. I have still some issues if I cought or sneeze, I am sorry for that from now. 

Today I'd like to start by showing the outline of today. Basically, it is divided into three parts. What is done What is current status and what are the plans for the next week. As you might see under what is done, firstly I will start by explaining really quickly what I've done in the tutorials. Then, we will go into the real topic of my thesis which is dynamic calibration of the buffer. Then, we are going to talk about the barriers problems I've countered during the implementation of my work. At the end, I will try to explain you what is my plans for the next two weeks.


Let's start by recaping what I've done in the tutorails. As you might guess, we, me and Alessia, started by implementing Ring Oscillator in the Virtuoso. We've done the schematic and analyze the results in different frequencies, temperatures, process corners etc. Then, we move to MATLAB part, where I've implemented a simple SARADC in that simulation. I've used the top-plate connected to input signal where bottom plate is connected to common mode voltages. I modulate this scenario. For VHDL, I've done the same thing. However, in this time, I've also tried to implement every single sub-component as a different entitiy, which was little bit challenging but it was okay at the end. By the way, to automate some stuffs, I've created a simple bash script, called as pre_xcel.sh if you run it it will create default cds.lib and list.f file tree and fill them with proper content. If you guys want to have this one, I can share it with you also.

I'd like to move to my real work, which is dynamic calibration. From previous week's presentation, I think Alessia has great slides to comprehend dynamic calibration. Firstly, I'd like to review them to show what changes I've done. As you can see, there is a simple diagram that shows a complete ADC, and my main work has been always over the just buffer part. Here is the input and output names for the buffer. Due to possible noise and distortion in the system. Vbuffer ofc is not equal to Vin. With dynamic calibration, I will try to find a way to fix this problem. The way that I've tried is that implementing a least mean square loop to calculate a coefficient values. We will go deeper into the LMS loop in the next slides. However, for now, we can assume that there are some coefficients that should be multiplied by the voltage Vbuffer and gives a result of Vin. If we find these magical coefficients we will get the output of the buffer as directly equal to the Vinput. Because as you can see after the output of the buffer, we can apply these coefficients and calibrate the voltage waveform. Now, we can go to the part of how to implement this LMS loop:

There are basically couple of ways to implement these coefficients, and the most compact way to implement this by using Volterra series. What it stands for is that we are going to force the system to find proper coefficients for any possible multiplication of values in any combination. However, for the case of memory polynomial, there are some terms that we omitted if you compare to the volterra series. The omitted terms are the ones with cross terms. I'd love to show a quick simple example with M is equal to 2 and P is equal to 2

As you can see, for the volterra series and memory polynomials linear part are the same since there is no cross terms over there. However, for the next 3 rows, there is a slight change. Volterra series takes care of y(n)multiplied by y(n-1) and y(n) multiplied by y(n-2) whereas the memory polynomial doesn't. Therefore, the number of coefficients for Volterra series is higer than Memory polynomial as expected. Also, in the case of volterra series, there is a strong dependency on polynomial since it shows the how many times we need to multiply the memorial term each other. If you realize that, if you also omit the memorial part in the memorial part, what you will end up with is that basically a power series since there will be only linear part.


Knowing these steps, now we can conclude the recap part and we can move to the problem that we've seen and how we solved or how not to. At the beggining, we directly run a transient simulation to get data from virtuoso input and output voltage values for the buffer. However, in Virtuoso, there is a time need to settle the voltage waveform so I needed to crop this voltage waveform from where it is stable. However, in this time, second problem came up, which is calculating THD and SFDR values. Since they are using NFFT to calculate these parameters, we needed to have a precise voltage samples in the waveform. To overcome this issues, rather than sampling at each frequency, we managed to get a specific number of samples to have the same last and initial voltage values. Afterwards, the THD and SFDR values for MATLAB and Virtuoso were the same. These are the problems that we've solved.

If we move to MATLAB part, there are some issues regarding to 